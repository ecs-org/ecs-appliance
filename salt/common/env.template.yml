{% macro ssl_secret(len=39) -%}
{{ salt['cmd.run_stdout']('openssl rand -base64 39') }}
{%- endmacro %}

{% macro gpg_secret(ownername) -%}
{%- set batch = 'Key-Type: 1\nKey-Length: 2048\nExpire-Date: 0\n'+
    'Name-Real: '+ ownername+ '\n%secring -&1\n%pubring -&2\n%commit\n' -%}
{%- set gpg_call = 'gpg --quiet --no-default-keyring --enable-special-filenames --batch --yes --armor --gen-key' -%}
{{ salt['cmd.run_stdout'](gpg_call, stdin=batch) }}
{%- endmacro %}

#### exchange ip number and add this to your domain config
# {{ domain }}.   IN  A     1.2.3.4
# {{ domain }}.   IN  MX    10  {{ domain }}
# {{ domain }}.   IN  TXT   "v=spf1 mx ptr -all"

# default ssh keys for appliance access (also used by cloud-config)
ssh_authorized_keys:
  - "your-sshkey here"
# # disabled ssh keys (they will be removed from the machine on state.highstate, if existing)
# ssh_deprecated_keys:
#   - "your-sshkey here"

# # create user accounts (also used by cloud-config)
# users:
#   - name: user
#     sudo: ['ALL=(ALL) NOPASSWD:ALL']
#     ssh-authorized-keys:
#       - "your-sshkey here"

appliance:
  # standby: true # optional, if set appliance will not activate
  domain: {{ domain }}
  allowed_hosts: {{ domain }}
  ssl:
    letsencrypt:
      enabled: true
    client_certs_mandatory: true
    # if true, always need a client certificate
    # key: filename-key.pem # optional, if set key for https host will be used
    # cert: filename-cert.pem # optional, if set cert for https host will be used
  storage:
    # setup: | # optional, will be executed if volatile or data can not be found
    # ignore_(volatile|data) # optional, if set will not look for filesystem
    ignore:
      volatile: true
      data: true
  # # set to your sentry url, must be the same as ecs_settings: SENTRY_DSN
  # sentry_dsn: 'https://url'
  backup:
    url: ssh://app@localhost/volatile/ecs-backup-test/
    encrypt: |
{{ gpg_secret('ecs_backup')|indent(8,True) }}

ecs:
  userswitcher:
    enabled: false
  settings: |
      DOMAIN = '{{ domain }}'
      ABSOLUTE_URL_PREFIX = 'https://{}'.format(DOMAIN)
      ALLOWED_HOSTS = [DOMAIN, ]
      PDFAS_SERVICE = ABSOLUTE_URL_PREFIX+ '/pdf-as-web/'
      SECURE_PROXY_SSL = True
      CLIENT_CERTS_REQUIRED = True
      DEBUG = False

      # SENTRY_DSN = 'https://url' # set to sentry url if available
      ETHICS_COMMISSION_UUID = 'ecececececececececececececececec'

      SECRET_KEY = '{{ ssl_secret() }}'
      REGISTRATION_SECRET = '{{ ssl_secret() }}'
      PASSWORD_RESET_SECRET = '{{ ssl_secret() }}'

      EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
      EMAIL_BACKEND_UNFILTERED = 'django.core.mail.backends.console.EmailBackend'
      EMAIL_UNFILTERED_DOMAINS = () # = ('example.com',)

      SMTPD_CONFIG['listen_addr'] = ('0.0.0.0', 8025)
      SMTPD_CONFIG['domain'] = DOMAIN

      # User registration, password reset, send client certificate and mail to
      # receivers at a domain included in EMAIL_UNFILTERED_DOMAINS will be sent via
      # EMAIL_BACKEND_UNFILTERED. All other mail will be sent via EMAIL_BACKEND.
      #
      # Backend to use to NOT sent email but log email to console:
      #   django.core.mail.backends.console.EmailBackend
      #
      # Backend to use to send via EMAIL_* smtp settings:
      #   django.core.mail.backends.smtp.EmailBackend
      #

  vault_encrypt: |
{{ gpg_secret('ecs_mediaserver')|indent(6,True) }}

  vault_sign: |
{{ gpg_secret('ecs_authority')|indent(6,True) }}
